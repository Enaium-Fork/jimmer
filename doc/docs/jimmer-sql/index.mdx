---
sidebar_position: 4
title: jimmer-sql subproject
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip
This article is copied from the part-ii of the homepage, and the content is exactly the same.

If you have already read the first part-ii of the homepage, you can skip this article and go straight to the more in-depth documentation.
:::

## Revolutionary ORM Based on the Immutable Data Model

1. Check for errors at compile time rather than runtime whenever possible with strong typed SQL DSL like JPA Criteria, QueryDSL, or JOOQ. Kotlin nullsafety would be introduced to SQL for kotlin API.
   
   <details>
   <summary>Quick view</summary>
     
   <Tabs groupId="language">
   <TabItem value="java" label="Java">
   
   ```java
   List<Book> books = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           return q
               .where(
                   book.id().in(
                       q.createSubQuery(AuthorTableEx.class, (sq, author) -> {
                           return sq
                               .where(
                                    author.firstName().eq("Alex")
                               )
                               .select(author.books().id());
                       })
                   )
               )
               .select(book);
        })
        .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val books = sqlClient
       .createQuery(Book::class) {
           where(
               table.id valueIn subQuery(Author::class) {
                   where(table.firstName eq "Alex")
                   select(table.books.id)
               }
           )
           select(table)
       }
       .execute()
   ```

   </TabItem>
   </Tabs>

   </details>


2. Strongly typed SQL DSL and Native SQL can be mixed without extra restrictions, Using database-specific features is very easy;

   <details>
   <summary>Quick view</summary>
     
   <Tabs groupId="language">
   <TabItem value="java" label="Java">
   
   ```java
   List<Tuple3<Book, Integer, Integer>> rows = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           return q.select(
               book,
               Expression.numeric().sql(
                   Integer.class,
                   "rank() over(order by %e desc)",
                   it -> {
                       it.expression(book.price());
                   }
               ),
               Expression.numeric().sql(
                   Integer.class,
                   "rank() over(partition by %e order by %e desc)",
                   it -> {
                       it.expression(book.store().id());
                       it.expression(book.price());
                   }
               )
           );
       })
       .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val rows = sqlClient
       .createQuery(Book::class) {
           select(
               table,
               sql(
                   Int::class, 
                   "rank() over(order by %e desc)"
               ) {
                   expression(table.price)
               },
               sql(
                   Int::class, 
                   "rank() over(partition by %e order by %e desc)"
               ) {
                   expression(table.store.id)
                   expression(table.price)
               }
           )
       }
       .execute()
   ```

   </TabItem>
   </Tabs>

   </details>

3. Always use much more efficient [ResultSet.getObject(int)](https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getObject(int)) instead of  [ResultSet.getObject(String)](https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getObject(java.lang.String))

4. Implicit dynamic table joins: automatically merge conflicting table joins in different code logic branches for complex dynamic queries *(Even with the highly controllable myBatis, it is difficult to implement this feature)*;

   <details>
   <summary>Quick view</summary>
   
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   public List<Book> findBooks(
           @Nullable String storeName,
           @Nullable String storeWebsite
   ) {
       return sqlClient
           .createQuery(BookTable.class, (q, book) -> {
               if (storeName != null) {
                   q.where(book.store().name().like(storeName));
               }
               if (storeWebsite != null) {
                   q.where(book.store().website().like(storeName));
               }
               return q.select(book);
           })
           .execute();
   }
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   fun findBooks(
       storeName: String?,
       storeWebsite: String?
   ): List<Book> =
       sqlClient
           .createQuery(Book::class) {
               storeName?.let { 
                   where(table.store.name like it)
               }
               storeWebsite?.let { 
                   where(table.store.website like it)
               }
               select(table)
           }
           .execute()
   ```

   </TabItem>
   </Tabs>

   In jimmer-sql table joins are implicit.

   Taking the above code as an example, `book.store()` in the Java code and `table.store` in the kotlin code represent the inner join of the association `Book::store`.

   Obviously, the above code implements a dynamic query, and different parameters will cause different SQL to be generated.

   When the above two conditions are met, in the final generated SQL, the table join of `Book::store` will only appear once, not twice. 
   </details>

5. In the paging scenario, developers only need to focus on querying the actual data, and the query on the number of rows is automatically generated and optimized by the framework.

   <details>
   <summary>Quick view</summary>
   
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   // Developers only need to focus on data-query
   ConfigurableRootQuery<Book> query = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           ... Omit some code logic, including: ...
           ... 1. Arbitrarily complex dynamic conditions ...
           ... 2. Arbitrarily complex dynamic sorting ...
           ... 3. Arbitrarily complex subqueries ...
           return q.select(book);
       });

   // count-query can be generated and optimized.
   TypedRootQuery<Long> countQuery = query
       .reselect((oldQuery, book) -> 
           oldQuery.select(book.count())
       )
       .withoutSortingAndPaging();

   int rowCount = countQuery.execute().get(0).intValue();

   //Query data from 1/3 to 2/3
   List<Book> books = query
       .limit(rowCount / 3, rowCount / 3)
       .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   // Developers only need to focus on data-query
   val query = sqlClient
       .createQuery(Book::class) {
           ... Omit some code logic, including: ...
           ... 1. Arbitrarily complex dynamic conditions ...
           ... 2. Arbitrarily complex dynamic sorting ...
           ... 3. Arbitrarily complex subqueries ...
           select(table)
       }

   // count-query can be generated and optimized.
   val countQuery = query
       .reselect {
           select(count(table))
       }
       .withoutSortingAndPaging()

   val rowCount = countQuery.execute()[0]

   //Query data from 1/3 to 2/3
   val books = query
       .limit(rowCount / 3, rowCount / 3)
       .execute()
   ```

   </TabItem>
   </Tabs>
   </details>

6. **Object Fetcher**: extend the ability of SQL. If a column in the query is an object type, it can be specified as the query format of the object. This format accepts any association depth and breadth and even allows recursively query self-association attributes. It can be considered that SQL has been extended to a capability comparable to GraphQL.

   <details>
   <summary>Quick view</summary>

   <details>
   <summary>Simple Fetcher</summary>
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   List<Book> books = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           q.orderBy(book.name());
           return q.select(
               book.fetch(
                   BookFetcher.$
                       .allScalarFields()
                       .store(
                           BookStoreFetcher.$
                               .allScalarFields()
                       )
                       .authors(
                           AuthorFetcher.$
                               .allScalarFields()
                       )
               )
           );
       })
       .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val books = sqlClient
       .createQuery(Book::class) {
           orderBy(table.name)
           select(
               table.fetchBy { 
                   allScalarFields()
                   store { 
                       allScalarFields()
                   }
                   authors { 
                       allScalarFields()
                   }
               }
           )
       }
       .execute()
   ```

   </TabItem>
   </Tabs>
   </details>

   <details>
   <summary>Fetcher With filter</summary>
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   List<Book> books = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           q.orderBy(book.name());
           return q.select(
               book.fetch(
                   BookFetcher.$
                       .allScalarFields()
                       .store(
                           BookStoreFetcher.$
                               .allScalarFields()
                       )
                       .authors(
                           AuthorFetcher.$
                               .allScalarFields(),
                           // This filter sorts the associated collection 
                           it -> it.filter(args -> {
                               args.orderBy(args.getTable().firstName());
                               args.orderBy(args.getTable().lastName());
                           })
                       )
               )
           );
       })
       .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val books = sqlClient
       .createQuery(Book::class) {
           orderBy(table.name)
           select(
               table.fetchBy { 
                   allScalarFields()
                   store { 
                       allScalarFields()
                   }
                   authors({
                        // This filter sorts the associated collection
                        filter { 
                            orderBy(table.firstName)
                            orderBy(table.lastName)
                        }
                    }) { 
                       allScalarFields()
                   }
               }
           )
       }
       .execute()
   ```

   </TabItem>
   </Tabs>
   </details>

   <details>
   <summary>Recursively query self-association attributes</summary>
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   List<TreeNode> rootNodes = sqlClient
       .createQuery(TreeNodeTable.class, (q, treeNode) -> {
           q.where(treeNode.parent().isNull());
           q.orderBy(treeNode.name());
           return q.select(
               treeNode.fetch(
                   TreeNodeFetcher.$
                       .allScalarFields()
                       .childNodes(
                           TreeNodeFetcher.$.allScalarFields(),
                           it -> {
                               // Recursively query, no matter how deep
                               it.recursive(args -> 
                                   // but exclude some subtrees
                                   !args.getEntity().name().equals("XX")
                               );
                               it.filter(args -> {
                                   args.orderBy(args.getTable().name());
                               });
                           }
                       )
               )
           );
       })
       .execute();
   ```
   
   </TabItem>
   <TabItem value="kotlin" label="Kotlin">
   
   ```kotlin
   val rootNodes = sqlClient
       .createQuery(TreeNode::class) {
           where(table.parent.isNull())
           orderBy(table.name)
           select(
               table.fetchBy {
                   allScalarFields()
                   childNodes({
                       // Recursively query, no matter how deep
                       recursive {
                           // but exclude some subtrees
                           entity.name != "XX"
                       }
                       filter { 
                           orderBy(table.name)
                       }
                   }) { 
                       allScalarFields()
                   }
               }
           )
       }
       .execute()
   ```
   
   </TabItem>
   </Tabs>
   </details>
   
   </details>

7. **Save Command**: the data to be saved is no longer a simple object, but an arbitrarily complex object tree. No matter how complex the tree is, the framework takes care of all the internal details and the developers can handle the whole operation with a single statement. This feature is the inverse of the Object Fetcher.

   <details>
   <summary>Quick view</summary>

   <details>
   <summary>Save lonely object</summary>

   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   Book toBeSaved = BookDraft.$.produce(book -> {
       book
           .setName("Algorithms")
           .setEdition(4)
           .setPrice(new BigDecimal("53.99"));
   });
   Book saved = sqlClient
       .getEntities()
       .save(toBeSaved)
       .getModifiedEntity();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val toBeSaved = new(Book::class).by {
       name = "Algorithms"
       edition = 4
       price = BigDecimal("53.99")
   }
   val saved = sqlClient
       .entities
       .save(toBeSaved)
       .modifiedEntity
   ```

   </TabItem>
   </Tabs>
   </details>

   <details>
   <summary>Save shallow object tree</summary>

   If the associated objects of the saved object only have id, then only the current object and its relationship with other objects can be modified (this may cause the middle table to be modified), not the associated objects themselves.

   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   Book toBeSaved = BookDraft.$.produce(book -> {
       book
           .setName("Algorithms")
           .setEdition(4)
           .setPrice(new BigDecimal("53.99"))
           .setStore(store -> {
               store.setId(7883L);
           })
           .addIntoAuthors(author -> {
             author.setId(28756L);
           })
           .addIntoAuthors(author -> {
               author.setId(634L);
           });
   });
   Book saved = sqlClient
       .getEntities()
       .save(toBeSaved)
       .getModifiedEntity();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val toBeSaved = new(Book::class).by {
       name = "Algorithms"
       edition = 4
       price = BigDecimal("53.99")
       store().apply {
           id = 7833L
       }
       authors().addBy {
           id = 28756L
       }
       authors().addBy {
           id = 634L
       }
   }
   val saved = sqlClient
       .entities
       .save(toBeSaved)
       .modifiedEntity
   ```

   </TabItem>
   </Tabs>
   </details>

   <details>
   <summary>Save deep object tree</summary>
   
   If the associated objects of the saved object contains non-id properties, then

   - Not only the current object and its relationship to other objects can be modified (which may cause the intermediate table to be modified), but also the associated objects can be further modified.

   - The depth of the saved object tree can be unlimited. However, no matter how deep it is, the framework can handle all the details inside it.

   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   Book toBeSaved = BookDraft.$.produce(book -> {
       book
           .setName("Algorithms")
           .setEdition(4)
           .setPrice(new BigDecimal("53.99"))
           .setStore(store -> {
               store.setName("O'REILLY");
           })
           .addIntoAuthors(author -> {
               author
                   .setFirstName("Robert")
                   .setLastName("Sedgewick")
                   .setGender(Gender.MALE);
           })
           .addIntoAuthors(author -> {
               author
                   .setFirstName("Kevin")
                   .setLastName("Wayne")
                   .setGender(Gender.MALE);
           });
   });
   Book saved = sqlClient
       .getEntities()
       .saveCommand(toBeSaved)
       .configure(it -> {
           // Automatically create non-existing associated objects
           it.setAutoAttachingAll();
       })
       .execute()
       .getModifiedEntity();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val toBeSaved = new(Book::class).by { 
       name = "Algorithms"
       edition = 4
       price = BigDecimal("53.99")
       store().apply { 
           name = "O'REILLY"
       }
       authors().addBy { 
           firstName = "Robert"
           lastName = "Sedgewick"
           gender = Gender.MALE
       }
       authors().addBy { 
           firstName = "Kevin"
           lastName = "Wayne"
           gender = Gender.MALE
       }
   }
   val saved = sqlClient
       .entities
       .save(toBeSaved) {
           // Automatically create non-existing associated objects
           setAutoAttachingAll()
       }
       .modifiedEntity
   ```

   </TabItem>
   </Tabs>
   </details>

   </details>

8. Work with any external cache. By default, the framework is just a very lightweight and powerful SQL generator without caching. Still, users can attach any external cache, **and keep it consistent with the business system's own cache technology**. Unlike other ORMs, it supports both object cache and also associative cache, and works with object fetchers, especially when recursively querying self-associative properties.

   :::warning
   This is an important and brand new feature, we will add the corresponding demo and documentation as soon as possible.
   :::

9. Extreme lightweight. No reflection, no dynamic bytecode generation, guarantee to be Graal friendly.
