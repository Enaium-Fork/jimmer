---
sidebar_position: 2
title: Mapping
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Annotation

Jimmer-sql uses these annotations

- org.babyfish.jimmer.Entity
- org.babyfish.jimmer.Table
- org.babyfish.jimmer.SequenceGenerator
- org.babyfish.jimmer.Transient
- org.babyfish.jimmer.Id
- org.babyfish.jimmer.GeneratedValue
- org.babyfish.jimmer.Version
- org.babyfish.jimmer.Column
- org.babyfish.jimmer.JoinColumn
- org.babyfish.jimmer.JoinTable
- org.babyfish.jimmer.OneToOne
- org.babyfish.jimmer.ManyToOne
- org.babyfish.jimmer.OneToMany
- org.babyfish.jimmer.ManyToMany
- org.babyfish.jimmer.sql.Key
- org.babyfish.jimmer.sql.OnDelete 

## Entity

The annotation `Entity` is used to decorate an immutable interface, representing an ORM entity.

:::note
1. Once `@Entity` is used, it is implied that the interface is immutable, no need to use `@org.babyfish.jimmer.Immutable`.

2. However, In java, `@Immutable` can specify the default nullability of the properties, so `@Entity` and `@Immutable` can be mixed. However, you should not do this in kotlin because 
:::

## Table

By default, the table name can be deduced from the interface name without using the `@Table` annotation.

The default table name uses all uppercase letters. Every place where the original name is switched from lowercase letter to uppercase letter will automatically add an underscore. For example, the interface name `BookStore` will automatically deduce the table name `BOOK_STORE`.

If the default table name does not meet your requirements, please use `@Tabale` to specify your table name.

```java title="BookStore.java"
@Entity
@Table("MY_BOOK_STORE")
public interface BookStore {
    ...
}
```

:::note
So far, only parse the property `name` of the `@Table`.
:::

## SequenceGenerator

This annotation is rarely used in jimmer-sql, and even if it is used, there are a few points to note.

:::caution
1. jimmer-sql only parses its properties `name` and `sequenceName`, and does not parse other attributes, especially `initialValue` and `allocationSize`.

2. If you want to use the table/database sharding technology and ensure the unique id of the logic table in different databases/tables, it is more recommended to use Snowflake id.
:::

## Transient

Indicates that a property does not need to be persisted.

ORM will not operate this property, and its best drinking scenarios are as follows

1. This property is a complex computed property, which cannot be obtained through ORM and needs to be implemented by coding in the business.

2. The data required for this property is not in the current database, and the upper-level business needs to get it from other microservices.

## Id

Declare a property as an id property, like this

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
@Entity
public interface Book {

    // highlight-next-line
    @Id
    long id();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"
@Entity
interface Book {

    // highlight-next-line
    @Id
    val id: Long
}
```

</TabItem>
</Tabs>



:::note
1. Id cannot be null. For java, it cannot be box type of 8 primtivie types; For kotlin, it cannot be nullable type.

2. Currently, jimmer-sql does not support composite id or multiple id properties.
:::

By default, the column name of the id column is derived from the Java property name.

By default all scalar column names use uppercase letters, and an underscore is automatically added wherever the original name is switched from lowercase letter to uppercase letter. The corresponding database column name here is ID.

## GeneratedValue

### generatorType

The annotation has an attribute named "generatorType", it must be an type of `IdGenerator`.

`IdGenerator` tells jimmer-sql how to insert objects without an id, which is defined as follows

```java title="IdGenerator"
package org.babyfish.jimmer.sql.meta;
public interface IdGenerator {}
```

Except `IdentityGenerator` and `SequenceGenerator`, `IdGenerator` interface has a typical implementation: `UserIdGenerator`. That means let user to write code that determines how the id is automatically generated.

```java title="UserIdGenerator.java"
package org.babyfish.jimmer.sql.meta;

public interface UserIdGenerator extends IdGenerator {

    Object generate(Class<?> entityType);
}
```

In particular, when the id is of type UUID, jimmer-sql provides a class called `org.babyfish.jimmer.sql.meta.UUIDIdGenerator` for generating UUIDs randomly

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Id
    @GeneratedValue(generateType = UUIDIdGenerator.class)
    UUID id();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Entity
interface Book {

    @Id
    @GeneratedValue(generateType = UUIDIdGenerator::class)
    val id: UUID
}
```

</TabItem>
</Tabs>

If you want to use snowflake id, you need to implement the interface `UserIdGenerator` by yourself, like this

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
public class SnowflakeIdGenerator implements UserIdGenerator {
    @Override
    public Long generate() {
        // Please call some third-party library 
        // to generate 64-bit snowflake id
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java
class SnowflakeIdGenerator : UserIdGenerator {
    override fun generate(): Long {
        // Please call some third-party library 
        // to generate 64-bit snowflake id
    }
}
```

</TabItem>
</Tabs>

Finally, you can use it like this

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Id
    @GeneratedValue(generateType = SnowflakeIdGenerator.class)
    val id: Long
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Entity
public interface Book {

    @Id
    @GeneratedValue(generateType = SnowflakeIdGenerator.class)
    val id: Long
}
```

</TabItem>
</Tabs>

### 2. IDENTITY

Use identity id/auto incremenet id of database

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Id
    @GeneratedValue(generatorType = IdentityGenerator::class)
    long id();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java
@Entity
interface Book {

    @Id
    @GeneratedValue(generatorType = IdentityGenerator::class)
    val id: Long
}
```

</TabItem>
</Tabs>

or

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    long id();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java
@Entity
interface Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long
}
```

</TabItem>
</Tabs>

### 3. SEQUENCE

Use sequence of database.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Id
    @GeneratedValue(
        generatorType = SequenceGenerator::class,
        sequenceName = "BOOK_ID_SEQ" // sequenceName is optional
    )
    long id();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java
@Entity
interface Book {

    @Id
    @GeneratedValue(
        generatorType = SequenceGenerator::class,
        sequenceName = "BOOK_ID_SEQ" // sequenceName is optional
    )
    val id: Long
}
```

</TabItem>
</Tabs>

or

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Id
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        sequenceName = "BOOK_ID_SEQ" // sequenceName is optional
    )
    long id();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java
@Entity
interface Book {

    @Id
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        sequenceName = "BOOK_ID_SEQ" // sequenceName is optional
    )
    val id: Long
}
```

</TabItem>
</Tabs>

If the `sequenceName` is not specified, the default value is `table name + "_ID_SEQ"`

## Version

Specifies the optimistic locking version property of the entity

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Version
    int version();

    ...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java
@Entity
interface Book {

    @Version
    val version: Int

    ...
}
```

</TabItem>
</Tabs>

:::note
Notice:

The version field must be non-null int type, `java.lang.Integer`(java) or `Int?`(kotlin) are invalid.
:::

## ManyToOne

There are two ways to implement many-to-one associations, based on foreign key and based on middle table.

### 1. Based on foreign key

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Null
    @ManyToOne
    BookStore store();

    ...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Entity
interface Book {

    @ManyToOne
    val store: BookStore?
}
```

</TabItem>
</Tabs>

Here, the foreign key column name is not explicitly specified by `@JoinColumn`, and the default column name is used.

The default column name uses all uppercase letters, every place where the Java property name is switched from lowercase letter to uppercase letter will automatically add an underscore, and finally append the suffix "_ID".

Here, the many-to-one attribute `store` will automatically deduce the foreign key column name `STORE_ID`.

It can also be used with `@JoinColum` with the explicit column name.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Null
    @ManyToOne
    @JoinColumn(name = "BOOK_STORE_ID")
    BookStore store();

    ...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Entity
interface Book {

    @ManyToOne
    @JoinColumn(name = "BOOK_STORE_ID")
    val store: BookStore?
}
```

</TabItem>
</Tabs>

:::note
So far, jimmer-sql does not support multiple `@JoinColumn` annotations for a property.
:::

### 2. Base on middle table

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Null
    @ManyToOne
    @JoinTable
    BookStore store();

    ...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java
@Entity
interface Book {

    @ManyToOne
    @JoinTable
    val store: BookStore?

    ...
}
```

</TabItem>
</Tabs>

Here, no annotation properties are specified for `@JoinTable`, the default properties are as follows

- `name`: BOOK_STORE_MAPPING.
- `joinColumnName`: BOOK_ID.
- `inverseJoinColumnName`: STORE_ID.

You can also specify it explicitly

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Entity
public interface Book {

    @Null
    @ManyToOne
    @JoinTable(
        name = "BOOK_STORE_MAPPING",
        joinColumns = @JoinColumn(name = "BOOK_ID")
        inverseJoinColumns = @JoinColumn(name = "STORE_ID")
    )
    BookStore store();

    ...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Entity
public interface Book {

    @ManyToOne
    @JoinTable(
        name = "BOOK_STORE_MAPPING",
        joinColumns = @JoinColumn(name = "BOOK_ID")
        inverseJoinColumns = @JoinColumn(name = "STORE_ID")
    )
    val store: BookStore?

    ...
}
```

</TabItem>
</Tabs>

:::caution
The many-to-one association based on the middle table must be nullable. 
:::

:::note
So far, jimmer-sql does not support
1. Specify multiple `@JoinColumn` annotations for the `joinColumns` or `inverseJoinColumns` of `@JoinTable`.
2. Specify `referencedColumnName` for `@JoinColumn` because it always refers to the id of the target table.
:::

## OneToOne

A one-to-one association must be the mirror of many-to-one association. That is, a one-to-one association necessarily implies a bidirectional association.

```java title="Address.java"
@Entity
public interface Adress {

    @ManyToOne
    Customer customer();
    ...
}
```

```java title="Customer.java"
@Entity
public interface Customer {

    // highlight-next-line
    @OneToOne(mappedBy = "customer")
    Address address();
    ...
}
```

:::caution
Property decorated with `@OneToOne` must be nullable
:::

## OneToMany

Unlike JPA, one-to-many association must be mirror of many-to-one association. That is, a one-to-many association necessarily implies a bidirectional association.

```java title="Book.java"
@Entity
public interface Book {

    @ManyToOne
    BookStore store();
    ...
}
```

```java title="Customer.java"
@Entity
public interface Customer {

    // highlight-next-line
    @OneToMany(mappedBy = "store")
    List<Boo> books();
    ...
}
```

:::caution
Collection properties are always treated as non-null, of course, including properties decorated by `@OneToMany`, using any nullable validation annotation will cause the annotation processor to report an error.
:::

## ManyToMany

:::caution
Collection properties are always treated as non-null, of course, including properties decorated by `@ManyToMany`, using any nullable validation annotation will cause the annotation processor to report an error.
:::

Since many-to-many associations can be used as the active side, they can also be used as the slave side.

### 1. Used as active side
```java
@Entity
public interface Book {

    @ManyToMany
    @JoinTable
    List<Author> autors();

    ...
}
```

Here, no annotation properties are specified for `@JoinTable`, the default properties are as follows

- `name`: own table name + "_" + opponent table name + "_" + "_MAPPING".
- `joinColumns`: a `@JoinColumn` object whose column name is the id column name of declaring entity.
- `inverseJoinColumns`: an `@JoinColumn` object whose column names are automatically inferred by attribute name uses uppercase letters. Every place where the original name is switched from lowercase letter to uppercase letter will automatically add an underscore, and finally add a suffix "_ID".

Assuming the column name of `Book.id` is `BOOK_ID`, then the above configuration is equivalent to
```java
@Entity
public interface Book {

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumns = @JoinColumn(name = "BOOK_ID")
        inverseColumns = @JoinColumn(name = "AUTHOR_ID")
    )
    List<Author> autors();

    ...
}
```
:::note
So far, jimmer-sql does not support
1. Specify multiple `@JoinColumn` annotations for the `joinColumns` or `inverseJoinColumns` of `@JoinTable`.
2. Specify `referencedColumnName` for `@JoinColumn` because it always refers to the id of the target table.
:::

### 2. Used as the slave side

```java
@Entity
public interface Author {

    @ManyToMany(mappedBy = "authors")
    List<Book> books();

    ...
}
```

## org.babyfish.jimmer.sql.Key

`@org.babyfish.jimmer.sql.Key` and `@Id` are similar but different.

- @Id is used to specify the technical primary key of the table.
- @Key is used to specify the business primary key of the table.

for example:

```java title="Book.java"
@Entity
public interface Book {

    @Id
    UUID id();

    @Key
    String name();

    @Key
    int edition();

    ...
}
```

- From a technical point of view, Book has a primary key `id`.

    The technical primary key often stores some unique data that does not make business sense, such as automatic numbering, serial value, UUID, and snowflake id. But it's simple enough so it can simplify table joins and optimize their performance.

- From a business point of view, `name` and `edition` combine to uniquely identify a book.

    Business primary key stores unique and business-meaningful data, and is often used in conjunction with multiple columns. But it is relatively complex and does not directly participate in the table joins.

:::note

1. In the document explaining the use of [Sava command](./mutation/save-command) to save data, we can see that the business primary key plays a very important role.

2. In addition to statically using the `@Key` annotation to specify the business primary key like this example, you can also dynamically specify the business primary key in the code, please see [Sava command](./mutation/save-command) for more information.
:::

## org.babyfish.jimmer.sql.OnDelete

It can only be used in many-to-one association based on foreign key, such as

```java
@Entity
public interface Book {

    @ManyToOne
    @OnDelete(DeleteAction.SET_NULL)
    BookStore store();
    ...
}
```

DeleteAction has 3 options, corresponding to the foreign key behavior of the database:

- NONE: The current foreign key does not support delete action, preventing its parent object from being deleted.
- SET_NULL: The foreign key is automatically cleared when the parent object is deleted. Corresponds to the SQL `on delete set null` statement, which can only be used for nullable foreign keys.
- DELETE: When the parent object is deleted, the current object is also automatically deleted. Corresponds to the SQL `on delete cascade` statement.