---
sidebar_position: 6
title: 缓存
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

默认情况下，该框架只是一个非常轻量级且功能强大的SQL生成器，没有缓存。 尽管如此，用户仍可以附加任何外部缓存，**并使其与业务系统自己的缓存技术保持一致**。 

与其他 ORM 不同，它同时支持对象缓存和关联缓存，并可与对象获取器一起使用，尤其是在递归查询自关联属性时。

框架提供一种自动保证数据库和缓存之间的一致性的方案。

## 基本概念

### 1. 对象缓存

此缓存把对象的id映射为实体对象，此对象为简单对象，并不包含深层次关联结构。

例子

|key|value|
|---|-----|
|BookStore-1|{"id":1,"name":"O'REILLY","website":null}|
|Book-1|{"id":1,"name":"Learning GraphQL","edition":1,"price":50.00,"store":{"id":1}}|
|Book-2|{"id":2,"name":"Learning GraphQL","edition":2,"price":55.00,"store":{"id":1}}|
|Book-3|{"id":3,"name":"Learning GraphQL","edition":3,"price":51.00,"store":{"id":1}}|
|Author-1|{"id":1,"firstName":"Eve","lastName":"Procello","gender":"FEMALE"}|
|Author-2|{"id":2,"firstName":"Alex","lastName":"Banks","gender":"MALE"}|
|TreeNode-1|{"id":1,"name":"Home","parent":null}|
|TreeNode-2|{"id":2,"name":"Food","parent":{"id":1}}|
|TreeNode-9|{"id":9,"name":"Clothing","parent":{"id":1}}|

### 2. 引用关联缓存

此缓存用于一对一和多对一关联，把当前对象id映射成关联对象的id

例子

|key|value|
|---|-----|
|Book.store-1|1|
|Book.store-2|1|
|Book.store-3|1|
|TreeNode.parent-2|1|
|TreeNode.parent-9|1|

:::info
注意：如果当前关联是基于外键的多对一关联，且当前对象已经明确包含了外键字段，系统不会使用该缓存。
:::

### 3. 集合关联缓存

此缓存用于一对多和多对多关联，把当前对象id映射成关联对象的id的列表

例子

|key|value|
|---|-----|
|BookStore.books-1|[1, 2, 3]|
|Book.authors-1|[1, 2]|
|Book.authors-2|[1, 2]|
|Book.authors-3|[1, 2]|
|Author.books-1|[1, 2, 3]|
|Author.books-2|[1, 2, 3]|
|TreeNode.childNodes-1|[9, 2]|

### 4. 计算属性缓存

此缓存用于用户自定义的计算字段，这种缓存会在计算属性一文中详细讲解，本文不予关注。

## 创建缓存

在为ORM配置缓存之前，需要先创建缓存对象。

jimmer-sql不对用户采用何种缓存技术做任何假设，用户可以使用任何缓存技术，只需适配为Cache接口即可。

```java title="Cache.java"
package org.babyfish.jimmer.sql.cache;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;

public interface Cache<K, V> {

    @Nullable V get(@NotNull K key, @NotNull CacheEnvironment<K, V> env);

    @NotNull Map<K, V> getAll(@NotNull Collection<K> keys, @NotNull CacheEnvironment<K, V> env);

    void delete(@NotNull K key);

    void delete(@NotNull K key, Object reason);

    void deleteAll(@NotNull Collection<K> keys);

    void deleteAll(@NotNull Collection<K> keys, @Nullable Object reason);
}
```

事实上，用户并不需要直接实现此接口，使用`ChainCacheBuilder`创建Cache实例是更推荐的模式。

### ChainCacheBuilder

实际项目中，缓存往往是多级的，`ChainCacheBuilder`用于帮助用户快速构建多级缓存。

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
Cache<K, V> cache = new ChainCacheBuilder<>()
    .add(new CaffeineBinder<>(512, Duration.ofSeconds(1)))
    .add(new RedisBinder<>(redisTemplate, type, Duration.ofMinutes(10)))
    .build();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val cache = ChainCacheBuilder<Any, Any>()
    .add(CaffeineBinder(512, Duration.ofSeconds(1)))
    .add(RedisBinder(redisTemplate, type, Duration.ofMinutes(10)))
    .build()
```

</TabItem>
</Tabs>

在这个例子中，我们构建了两级缓存。

- 第一级缓存是JVM内部的内存缓存，基于caffeine实现。
- 第二级缓存是可共享的分布式内存缓存，基于redis实现。

前文提到，jimmer-sql不对用户采用何种缓存技术做任何假设，上述代码中的`CaffeineBinder`和`RedisBinder`并不是框架提供的类型，而是用户实现的类型。

用户可以随意选择自己喜欢的缓存技术，并为它们编写`Binder`适配类，这些适配类型需要实现jimmer-sql提供的接口：`LoadingBinder`或`SimpleBinder`。

#### 1. LoadingBinder

某些缓存技术，比如Caffine和Guava，能够自行判断被查询数据是否已经存在，如果不存在，则自动从数据库或下一级缓存中加载。

对于这类缓存技术，其适配类应该实现`LoadingBinder`接口。

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="CaffeineBinder.java"
public class CaffeineBinder<K, V> implements LoadingBinder<K, V> {

    private final int maximumSize;

    private final Duration duration;

    private LoadingCache<
        K, 
        // Caffeine does not support null value, 
        // use `Optional<T>` as a wrapper
        Optional<V>
    > loadingCache;

    public CaffeineBinder(int maximumSize, Duration duration) {
        this.maximumSize = maximumSize;
        this.duration = duration;
    }

    @Override
    public void initialize(
        // `chain` tells caffine how to load the non-existing 
        // data from database or next level cache.
        CacheChain<K, V> chain
    ) {
        loadingCache = Caffeine
                .newBuilder()
                .maximumSize(maximumSize)
                .expireAfterWrite(duration)
                .build(
                        new CacheLoader<K, Optional<V>>() {

                            @Override
                            public Optional<V> load(K key) {
                                // Load from database or next level cache
                                Map<K, V> map = chain.loadAll(
                                    Collections.singleton(key)
                                );
                                V value = map.get(key);
                                if (value != null || map.containsKey(key)) {
                                    return Optional.ofNullable(value);
                                }
                                return Optional.ofNullable(null);
                            }

                            @SuppressWarnings("unchecked")
                            @Override
                            public Map<? extends K, ? extends Optional<V>> loadAll(
                                Set<? extends K> keys
                            ) {
                                // Load from database or next level cache
                                Map<K, V> map = chain.loadAll((Collection<K>) keys);
                                return map
                                    .entrySet()
                                    .stream()
                                    .collect(
                                        Collectors.toMap(
                                            Map.Entry::getKey,
                                            e -> Optional.ofNullable(e.getValue())
                                        )
                                    );
                            }
                        }
                );
    }

    @Override
    public Map<K, V> getAll(Collection<K> keys) {
        Map<K, Optional<V>> map = loadingCache.getAll(keys);
        Map<K, V> convertedMap = new HashMap<>((map.size() * 4 + 2) / 3);
        for (Map.Entry<K, Optional<V>> e : map.entrySet()) {
            convertedMap.put(e.getKey(), e.getValue().orElse(null));
        }
        return convertedMap;
    }

    @Override
    public void deleteAll(@NotNull Collection<K> keys, Object reason) {
        // If user want delete keys from 
        // 1. all sub caches in the cache chain
        // 2. or caffeine sub cache.
        if (reason == null || reason.equals("caffeine")) {
            loadingCache.invalidateAll(keys);
        }
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="CaffeineBinder.kt"
class CaffeineBinder<K: Any, V: Any>(
    private val maximumSize: Int, 
    private val duration: Duration
) : LoadingBinder<K, V> {
    
    private lateinit var loadingCache: LoadingCache<
        K, 
        // Caffeine does not support null value, 
        // use `Optional<V>` as a wrapper
        Optional<V>
    >
    
    override fun initialize(
        // `chain` tells caffine how to load the non-existing 
        // data from database or next level cache.
        chain: CacheChain<K, V>
    ) {
        // Create caffeine cache
        loadingCache = Caffeine
            .newBuilder()
            .maximumSize(maximumSize.toLong())
            .expireAfterWrite(duration)
            .build(
                object : CacheLoader<K, Optional<V>> {

                    override fun load(key: K): Optional<V> {
                        // Load from database or next level cache
                        val map = chain.loadAll(setOf(key))
                        val value = map[key]
                        return if (value != null || map.containsKey(key)) {
                            Optional.ofNullable(value)
                        } else {
                            Optional.ofNullable(null)
                        }
                    }

                    override fun loadAll(
                        keys: Set<K>
                    ): Map<out K, Optional<V>> =
                        // Load from database or next level cache
                        chain.loadAll((keys as Collection<K>)).mapValues {
                            Optional.ofNullable(it.value)
                        }
                }
            )
    }

    override fun getAll(keys: Collection<K>): Map<K, V> =
        loadingCache.getAll(keys).mapValues {
            it.value.orElse(null)
        }

    override fun deleteAll(keys: Collection<K>, reason: Any?) {
        // If user want delete keys from 
        // 1. all sub caches in the cache chain
        // 2. or caffeine sub cache.
        if (reason === null || reason == "caffeine") {
            loadingCache.invalidateAll(keys)
        }
    }
}
```

</TabItem>
</Tabs>

#### 2. SimpleBinder

某些缓存技术，比如redis，只支持get/set操作，需要开发人员判断被查询数据是否已经存在，如果不存在，由开发人员从数据库或下一级缓存中加载。

对于这类缓存技术，其适配类应该实现`SimpleBinder`接口。

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="RedisBinder.java"
public class RedisBinder<K, V> implements SimpleBinder<K, V> {

    private static final Logger LOGGER = LoggerFactory.getLogger(RedisBinder.class);

    private final RedisOperations<String, byte[]> operations;

    private final String keyPrefix;

    private final Duration duration;

    private final int randomPercent;

    // For cached values, don't use spring-redis's RedisSerializer, 
    // use `org.babyfish.jimmer.sql.cache.ValueSerializer`.
    // 
    // Its internal work has a certain complexity, 
    // and it is not easy to be implemented by user.
    private final ValueSerializer<V> valueSerializer;

    public RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableType type,
            Duration duration
    ) {
        this(operations, type, duration, 30);
    }

    public RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableProp prop,
            Duration duration
    ) {
        this(operations, prop, duration, 30);
    }

    public RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableProp prop,
            Duration duration,
            int randomPercent
    ) {
        this(operations, null, prop, duration, randomPercent);
    }

    public RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableType type,
            Duration duration,
            int randomPercent
    ) {
        this(operations, type, null, duration, randomPercent);
    }

    private RedisBinder(
            RedisOperations<String, byte[]> operations,
            ImmutableType type,
            ImmutableProp prop,
            Duration duration,
            int randomPercent
    ) {
        if ((type == null) == (prop == null)) {
            throw new IllegalArgumentException("Illegal metadata");
        }
        if (randomPercent < 0 || randomPercent > 100) {
            throw new IllegalArgumentException("randomPercent must between 0 and 100");
        }
        this.operations = operations;
        if (type != null) {
            // Prefix for object, for example: 'Book-'
            this.keyPrefix = type.getJavaClass().getSimpleName() + '-';
        } else {
            // Prefix for property, for example: 'Book.authors-'
            this.keyPrefix = 
                prop.getDeclaringType().getJavaClass().getSimpleName() + 
                '.' + 
                prop.getName() + 
                '-';
        }
        this.duration = duration;
        this.randomPercent = randomPercent;
        if (type != null) {
            valueSerializer = new ValueSerializer<>(type);
        } else {
            valueSerializer = new ValueSerializer<>(prop);
        }
    }

    // How to read value from redis
    @Override
    public Map<K, V> getAll(Collection<K> keys) {
        List<byte[]> values = operations
            .opsForValue()
            .multiGet(
                keys.stream()
                .map(it -> keyPrefix + it)
                .collect(Collectors.toList())
            );
        return valueSerializer.deserialize(keys, values);
    }

    // How to set value into redis
    @SuppressWarnings("unchecked")
    @Override
    public void setAll(Map<K, V> map) {
        Map<String, byte[]> convertedMap = 
            valueSerializer.serialize(map, key -> keyPrefix + key);
        if (LOGGER.isInfoEnabled()) {
            LOGGER.info("save into redis: {}", convertedMap.keySet());
        }
        long millis = duration.toMillis();
        long min = millis - randomPercent * millis / 100;
        long max = millis + randomPercent * millis / 100;
        ThreadLocalRandom random = ThreadLocalRandom.current();
        operations.executePipelined(
                new SessionCallback<Void>() {
                    @Override
                    public <XK, XV> Void execute(
                        RedisOperations<XK, XV> pops
                    ) throws DataAccessException {
                        RedisOperations<String, byte[]> pipelinedOps = 
                            (RedisOperations<String, byte[]>)pops;
                        pipelinedOps.opsForValue().multiSet(convertedMap);
                        for (String key : convertedMap.keySet()) {
                            pipelinedOps.expire(
                                    key,
                                    random.nextLong(min, max),
                                    TimeUnit.MILLISECONDS
                            );
                        }
                        return null;
                    }
                }
        );
    }

    @Override
    public void deleteAll(Collection<K> keys, Object reason) {
        // If user want delete keys from 
        // 1. all sub caches in the cache chain
        // 2. or redis sub cache.
        if (reason == null || reason.equals("redis")) {
            Collection<String> redisKeys = 
                keys
                    .stream()
                    .map(it -> keyPrefix + it)
                    .collect(Collectors.toList());
            LOGGER.info("delete from redis: {}", redisKeys);
            operations.delete(redisKeys);
        }
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java title="RedisBinder.kt"
class RedisBinder<K, V> private constructor(
    operations: RedisOperations<String, ByteArray>,
    type: ImmutableType?,
    prop: ImmutableProp?,
    duration: Duration,
    randomPercent: Int
) : SimpleBinder<K, V> {

    private val operations: RedisOperations<String, ByteArray>

    private val keyPrefix: String

    private val duration: Duration

    private val randomPercent: Int

    // For cached values, don't use spring-redis's RedisSerializer, 
    // use `org.babyfish.jimmer.sql.cache.ValueSerializer`.
    // 
    // Its internal work has a certain complexity, 
    // and it is not easy to be implemented by user.
    private var valueSerializer: ValueSerializer<V>

    init {
        require(type == null != (prop == null)) { 
            "Illegal metadata" 
        }
        require(!(randomPercent < 0 || randomPercent > 100)) { 
            "randomPercent must between 0 and 100" 
        }
        this.operations = operations
        keyPrefix = if (type != null) {
            // Prefix for object, for example: 'Book-'
            "${type.javaClass.simpleName}-"
        } else {
            // Prefix for property, for example: 'Book.authors-'
            "${prop!!.declaringType.javaClass.simpleName}.${prop.name}-"
        }
        this.duration = duration
        this.randomPercent = randomPercent
        valueSerializer = type
            ?.let { ValueSerializer(it) } 
            ?: ValueSerializer(prop!!)
    }

    constructor(
        operations: RedisOperations<String, ByteArray>,
        type: ImmutableType,
        duration: Duration,
        randomPercent: Int = 30
    ) : this(operations, type, null, duration, randomPercent)

    constructor(
        operations: RedisOperations<String, ByteArray>,
        prop: ImmutableProp,
        duration: Duration,
        randomPercent: Int = 30
    ) : this(operations, null, prop, duration, randomPercent)

    // How to read value from redis
    override fun getAll(keys: Collection<K>): Map<K, V> {
        val values = operations.opsForValue().multiGet(
            keys.map { "$keyPrefix$it" }
        )
        return valueSerializer.deserialize(keys, values!!)
    }

    // How to set value into redis
    @Suppress("UNCHECKED_CAST")
    override fun setAll(map: Map<K, V>) {
        val convertedMap = valueSerializer.serialize(map) { "$keyPrefix$it" }
        if (LOGGER.isInfoEnabled) {
            LOGGER.info("save into redis: {}", convertedMap.keys)
        }
        val millis = duration.toMillis()
        val min = millis - randomPercent * millis / 100
        val max = millis + randomPercent * millis / 100
        val random = ThreadLocalRandom.current()
        operations.executePipelined(
            object : SessionCallback<Void?> {
                override fun <XK, XV> execute(pops: RedisOperations<XK, XV>): Void? {
                    val pipelinedOps = pops as RedisOperations<String, ByteArray>
                    pipelinedOps.opsForValue().multiSet(convertedMap)
                    for (key in convertedMap.keys) {
                        pipelinedOps.expire(
                            key,
                            random.nextLong(min, max),
                            TimeUnit.MILLISECONDS
                        )
                    }
                    return null
                }
            }
        )
    }

    override fun deleteAll(keys: Collection<K>, reason: Any?) {
        // If user want delete keys from 
        // 1. all sub caches in the cache chain
        // 2. or redis sub cache.
        if (reason === null || reason == "redis") {
            val redisKeys: Collection<String> = keys.map { "$keyPrefix$it" }
            LOGGER.info("delete from redis: {}", redisKeys)
            operations.delete(redisKeys)
        }
    }

    companion object {
        private val LOGGER = LoggerFactory.getLogger(RedisBinder::class.java)
    }
}
```

</TabItem>
</Tabs>

## 配置缓存

### 构建RedisTemplate

在这个例子中，我们的二级缓存使用了redis，所以要先创建`RedisTemplate`

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public RedisTemplate<String, byte[]> rawDataRedisTemplate(
    // Inject connection factory of spring data redis
    RedisConnectionFactory connectionFactory
) {
    RedisTemplate<String, byte[]> template = new RedisTemplate<>();
    template.setConnectionFactory(connectionFactory);
    template.setKeySerializer(StringRedisSerializer.UTF_8);

    // Specify a dummy serializer for spring redis because 
    // `org.babyfish.jimmer.sql.example.cache.ValueSerializer` took over the job.
    template.setValueSerializer(
            new RedisSerializer<byte[]>() {
                @Override
                public byte[] serialize(byte[] bytes) throws SerializationException {
                    return bytes;
                }
                @Override
                public byte[] deserialize(byte[] bytes) throws SerializationException {
                    return bytes;
                }
            }
    );
    return template;
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun rawDataRedisTemplate(
    // Inject connection factory of spring data redis
    connectionFactory: RedisConnectionFactory
): RedisTemplate<String, ByteArray> =
    RedisTemplate<String, ByteArray>().apply {
        setConnectionFactory(connectionFactory)
        keySerializer = StringRedisSerializer.UTF_8

        // Specify a dummy serializer for spring redis because
        // `org.babyfish.jimmer.sql.example.cache.ValueSerializer` took over the job.
        valueSerializer =
            object : RedisSerializer<ByteArray?> {
                override fun serialize(t: ByteArray?): ByteArray? = t
                override fun deserialize(bytes: ByteArray?): ByteArray? = bytes
            }
    }
```

</TabItem>
</Tabs>

有两种方法为jimmer-sql配置缓存，显式配置和隐式配置。

### 显式配置

#### 1. 配置对象缓存

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java

```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
```

</TabItem>
</Tabs>

### 隐式配置

## 缓存一致性

### 环境搭建

### 验证数据一致性