---
sidebar_position: 4
title: jimmer-sql子项目
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip
对于中文版，从本文档中挑取最重要的一部分，形成[B站视频集](https://www.bilibili.com/video/BV1dA4y1R7pV/?vd_source=60313648ad86e28e629f98e944f7fa2a)
:::

:::tip
本文从首页的第二部分复制而来，内容完全一样。

如果你已经阅读过首页的第二部分，可以跳过本文，直接阅读更深的文档。
:::

## 基于不可变数据模型的革命性的ORM

1. 和JPA Criteria、QueryDSL或JOOQ一样，使用强类型SQL DSL，在编译时而不是运行时检查错误。 Kotlin API还会把kotlin的空安全引入到SQL中。
   
   <details>
   <summary>快速预览</summary>
     
   <Tabs groupId="language">
   <TabItem value="java" label="Java">
   
   ```java
   List<Book> books = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           return q
               .where(
                   book.id().in(
                       q.createSubQuery(AuthorTableEx.class, (sq, author) -> {
                           return sq
                               .where(
                                    author.firstName().eq("Alex")
                               )
                               .select(author.books().id());
                       })
                   )
               )
               .select(book);
        })
        .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val books = sqlClient
       .createQuery(Book::class) {
           where(
               table.id valueIn subQuery(Author::class) {
                   where(table.firstName eq "Alex")
                   select(table.books.id)
               }
           )
           select(table)
       }
       .execute()
   ```

   </TabItem>
   </Tabs>

   </details>

2. 强类型SQL DSL和Native SQL可以混合使用，没有额外的限制，使用数据库特定的特性是非常容易的。

   <details>
   <summary>快速预览</summary>
     
   <Tabs groupId="language">
   <TabItem value="java" label="Java">
   
   ```java
   List<Tuple3<Book, Integer, Integer>> rows = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           return q.select(
               book,
               Expression.numeric().sql(
                   Integer.class,
                   "rank() over(order by %e desc)",
                   it -> {
                       it.expression(book.price());
                   }
               ),
               Expression.numeric().sql(
                   Integer.class,
                   "rank() over(partition by %e order by %e desc)",
                   it -> {
                       it.expression(book.store().id());
                       it.expression(book.price());
                   }
               )
           );
       })
       .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val rows = sqlClient
       .createQuery(Book::class) {
           select(
               table,
               sql(
                   Int::class, 
                   "rank() over(order by %e desc)"
               ) {
                   expression(table.price)
               },
               sql(
                   Int::class, 
                   "rank() over(partition by %e order by %e desc)"
               ) {
                   expression(table.store.id)
                   expression(table.price)
               }
           )
       }
       .execute()
   ```

   </TabItem>
   </Tabs>

   </details>

3. 始终使用效率更高的 [ResultSet.getObject(int)](https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getObject(int)) 而不是 [ResultSet. getObject(String)](https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getObject(java.lang.String))

4. 隐式动态表连接：对于复杂的动态查询，自动合并不同代码逻辑分支中冲突的表连接 *（即使是高度可控的myBatis，也很难实现这个特性）*；

   <details>
   <summary>快速预览</summary>
   
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   public List<Book> findBooks(
           @Nullable String storeName,
           @Nullable String storeWebsite
   ) {
       return sqlClient
           .createQuery(BookTable.class, (q, book) -> {
               if (storeName != null) {
                   q.where(book.store().name().like(storeName));
               }
               if (storeWebsite != null) {
                   q.where(book.store().website().like(storeName));
               }
               return q.select(book);
           })
           .execute();
   }
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   fun findBooks(
       storeName: String?,
       storeWebsite: String?
   ): List<Book> =
       sqlClient
           .createQuery(Book::class) {
               storeName?.let { 
                   where(table.store.name like it)
               }
               storeWebsite?.let { 
                   where(table.store.website like it)
               }
               select(table)
           }
           .execute()
   ```

   </TabItem>
   </Tabs>

   在jimmer-sql中，表连接是隐式的。

   以上述代码为例，Java代码中的`book.store()`和kotlin代码中的`table.store`代表关联`Book::store`的内连接。

   显然，上面的代码实现了动态查询，不同的参数会导致生成不同的SQL。

   当以上两个条件都满足时，在最终生成的SQL中，`Book::store`的表连接只会出现一次，而非两次。
   </details>

5. 在分页场景下，开发者只需要专注于查询实际数据，对行数的查询由框架自动生成和优化。

   <details>
   <summary>快速预览</summary>
   
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   // 开发者只需要专注于查询实际数据
   ConfigurableRootQuery<Book> query = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           ... 省略一些代码逻辑，包含: ...
           ... 1. 任意复杂的动态条件 ...
           ... 2. 任意复杂的动态拍戏 ...
           ... 3. 任意复杂的子查询 ...
           return q.select(book);
       });

   // 对行数的查询由框架自动生成和优化。
   TypedRootQuery<Long> countQuery = query
       .reselect((oldQuery, book) -> 
           oldQuery.select(book.count())
       )
       .withoutSortingAndPaging();

   int rowCount = countQuery.execute().get(0).intValue();

   // 查询从1/3处到2/3的部分数据
   List<Book> books = query
       .limit(rowCount / 3, rowCount / 3)
       .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   // 开发者只需要专注于查询实际数据
   val query = sqlClient
       .createQuery(Book::class) {
           ... 省略一些代码逻辑，包含: ...
           ... 1. 任意复杂的动态条件 ...
           ... 2. 任意复杂的动态拍戏 ...
           ... 3. 任意复杂的子查询 ...
           select(table)
       }

   // 对行数的查询由框架自动生成和优化。
   val countQuery = query
       .reselect {
           select(count(table))
       }
       .withoutSortingAndPaging()

   val rowCount = countQuery.execute()[0]

   // 查询从1/3处到2/3的部分数据
   val books = query
       .limit(rowCount / 3, rowCount / 3)
       .execute()
   ```

   </TabItem>
   </Tabs>
   </details>

6. **Object Fetcher**：扩展SQL的能力。 如果查询中的列是对象类型，则可以为其指定查询格式。 这种格式接受任何关联深度和广度，甚至允许递归查询自关联属性。 可以认为SQL被扩展了可媲美于GraphQL的能力。

   <details>
   <summary>快速预览</summary>

   <details>
   <summary>简单抓取器</summary>
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   List<Book> books = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           q.orderBy(book.name());
           return q.select(
               book.fetch(
                   BookFetcher.$
                       .allScalarFields()
                       .store(
                           BookStoreFetcher.$
                               .allScalarFields()
                       )
                       .authors(
                           AuthorFetcher.$
                               .allScalarFields()
                       )
               )
           );
       })
       .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val books = sqlClient
       .createQuery(Book::class) {
           orderBy(table.name)
           select(
               table.fetchBy { 
                   allScalarFields()
                   store { 
                       allScalarFields()
                   }
                   authors { 
                       allScalarFields()
                   }
               }
           )
       }
       .execute()
   ```

   </TabItem>
   </Tabs>
   </details>

   <details>
   <summary>使用过滤器</summary>
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   List<Book> books = sqlClient
       .createQuery(BookTable.class, (q, book) -> {
           q.orderBy(book.name());
           return q.select(
               book.fetch(
                   BookFetcher.$
                       .allScalarFields()
                       .store(
                           BookStoreFetcher.$
                               .allScalarFields()
                       )
                       .authors(
                           AuthorFetcher.$
                               .allScalarFields(),
                           // 此过滤器对关联集合进行排序 
                           it -> it.filter(args -> {
                               args.orderBy(args.getTable().firstName());
                               args.orderBy(args.getTable().lastName());
                           })
                       )
               )
           );
       })
       .execute();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val books = sqlClient
       .createQuery(Book::class) {
           orderBy(table.name)
           select(
               table.fetchBy { 
                   allScalarFields()
                   store { 
                       allScalarFields()
                   }
                   authors({
                        // 此过滤器对关联集合进行排序
                        filter { 
                            orderBy(table.firstName)
                            orderBy(table.lastName)
                        }
                    }) { 
                       allScalarFields()
                   }
               }
           )
       }
       .execute()
   ```

   </TabItem>
   </Tabs>
   </details>

   <details>
   <summary>递归查询自关联属性</summary>
   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   List<TreeNode> rootNodes = sqlClient
       .createQuery(TreeNodeTable.class, (q, treeNode) -> {
           q.where(treeNode.parent().isNull());
           q.orderBy(treeNode.name());
           return q.select(
               treeNode.fetch(
                   TreeNodeFetcher.$
                       .allScalarFields()
                       .childNodes(
                           TreeNodeFetcher.$.allScalarFields(),
                           it -> {
                               // 递归查询，无论多深
                               it.recursive(args -> 
                                   // 但，排除某些子树
                                   !args.getEntity().name().equals("XX")
                               );
                               it.filter(args -> {
                                   args.orderBy(args.getTable().name());
                               });
                           }
                       )
               )
           );
       })
       .execute();
   ```
   
   </TabItem>
   <TabItem value="kotlin" label="Kotlin">
   
   ```kotlin
   val rootNodes = sqlClient
       .createQuery(TreeNode::class) {
           where(table.parent.isNull())
           orderBy(table.name)
           select(
               table.fetchBy {
                   allScalarFields()
                   childNodes({
                       // 递归查询，无论多深
                       recursive {
                           // 但，排除某些子树
                           entity.name != "XX"
                       }
                       filter { 
                           orderBy(table.name)
                       }
                   }) { 
                       allScalarFields()
                   }
               }
           )
       }
       .execute()
   ```
   
   </TabItem>
   </Tabs>
   </details>
   
   </details>

7. **Save command**：要保存的数据不再是简单的对象，而是任意复杂的对象树。 无论树有多复杂，框架都会处理所有内部细节，开发人员可以用一条语句处理整个操作。 此功能是Object Fetcher的逆功能。

   <details>
   <summary>快速预览</summary>

   <details>
   <summary>保存孤单的对象</summary>

   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   Book toBeSaved = BookDraft.$.produce(book -> {
       book
           .setName("Algorithms")
           .setEdition(4)
           .setPrice(new BigDecimal("53.99"));
   });
   Book saved = sqlClient
       .getEntities()
       .save(toBeSaved)
       .getModifiedEntity();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val toBeSaved = new(Book::class).by {
       name = "Algorithms"
       edition = 4
       price = BigDecimal("53.99")
   }
   val saved = sqlClient
       .entities
       .save(toBeSaved)
       .modifiedEntity
   ```

   </TabItem>
   </Tabs>
   </details>

   <details>
   <summary>保存浅的对象树</summary>

   如果被保存对象的关联对象只有id，那么只会修改当前对象及其与其他对象的关系（这可能会导致中间表被修改），而关联对象本身不会被修改。

   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   Book toBeSaved = BookDraft.$.produce(book -> {
       book
           .setName("Algorithms")
           .setEdition(4)
           .setPrice(new BigDecimal("53.99"))
           .setStore(store -> {
               store.setId(7883L);
           })
           .addIntoAuthors(author -> {
             author.setId(28756L);
           })
           .addIntoAuthors(author -> {
               author.setId(634L);
           });
   });
   Book saved = sqlClient
       .getEntities()
       .save(toBeSaved)
       .getModifiedEntity();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val toBeSaved = new(Book::class).by {
       name = "Algorithms"
       edition = 4
       price = BigDecimal("53.99")
       store().apply {
           id = 7833L
       }
       authors().addBy {
           id = 28756L
       }
       authors().addBy {
           id = 634L
       }
   }
   val saved = sqlClient
       .entities
       .save(toBeSaved)
       .modifiedEntity
   ```

   </TabItem>
   </Tabs>
   </details>

   <details>
   <summary>保存深的对象树</summary>
   
   如果被保存对象的关联对象包含非id属性，则

   - 不仅可以修改当前对象及其与其他对象的关系（可能导致修改中间表），还可以进一步修改关联对象。

   - 被保存对象树的深度可以不受限制。 然而，无论它有多深，框架都可以处理其中的所有细节。

   <Tabs groupId="language">
   <TabItem value="java" label="Java">

   ```java
   Book toBeSaved = BookDraft.$.produce(book -> {
       book
           .setName("Algorithms")
           .setEdition(4)
           .setPrice(new BigDecimal("53.99"))
           .setStore(store -> {
               store.setName("O'REILLY");
           })
           .addIntoAuthors(author -> {
               author
                   .setFirstName("Robert")
                   .setLastName("Sedgewick")
                   .setGender(Gender.MALE);
           })
           .addIntoAuthors(author -> {
               author
                   .setFirstName("Kevin")
                   .setLastName("Wayne")
                   .setGender(Gender.MALE);
           });
   });
   Book saved = sqlClient
       .getEntities()
       .saveCommand(toBeSaved)
       .configure(it -> {
           // 如果某些关联对象不存在，自动创建它们
           it.setAutoAttachingAll();
       })
       .execute()
       .getModifiedEntity();
   ```

   </TabItem>
   <TabItem value="kotlin" label="Kotlin">

   ```kotlin
   val toBeSaved = new(Book::class).by { 
       name = "Algorithms"
       edition = 4
       price = BigDecimal("53.99")
       store().apply { 
           name = "O'REILLY"
       }
       authors().addBy { 
           firstName = "Robert"
           lastName = "Sedgewick"
           gender = Gender.MALE
       }
       authors().addBy { 
           firstName = "Kevin"
           lastName = "Wayne"
           gender = Gender.MALE
       }
   }
   val saved = sqlClient
       .entities
       .save(toBeSaved) {
           // 如果某些关联对象不存在，自动创建它们
           setAutoAttachingAll()
       }
       .modifiedEntity
   ```

   </TabItem>
   </Tabs>
   </details>

   </details>

8. 允许使用任何外部缓存。 默认情况下，该框架只是一个非常轻量级且功能强大的SQL生成器，没有缓存。 尽管如此，用户仍可以附加任何外部缓存，**并使其与业务系统自己的缓存技术保持一致**。 与其他 ORM 不同，它同时支持对象缓存和关联缓存，并可与对象获取器一起使用，尤其是在递归查询自关联属性时。

   :::warning
   这是一个重要的特性，但也是一个新功能，我们会尽快添加相应的例子和文档。
   :::

9. 极致的轻量化，无反射，无动态字节码生成，保证对 Graal 友好。
