---
sidebar_position: 1
title: 快速上手
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

jimmer-sql内容相对较多，后续文章会逐步讲解。本文对其部分功能进行一个简单的罗列，让读者有一个感性的认知。

## 导入依赖

<Tabs groupId="language">
<TabItem value="java" label="Java">

```groovy title="build.gradle"
depdencies {
    
    implementation 'org.babyfish.jimmer:jimmer-sql:0.1.29'
    annotationProcessor 'org.babyfish.jimmer:jimmer-apt:0.1.29'

    runtimeOnly 'com.h2database:h2:2.1.212'
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="build.gradle.kts"
plugins {
    // Step1: Add ksp plugin
	id("com.google.devtools.ksp") version "1.7.10-1.0.6"

    ...ommit other plugins...
}
depdencies {
    
    // Step2: Add jimmer-sql-kotlin
    implementation("org.babyfish.jimmer:jimmer-sql-kotlin:0.1.29")

    // Step3: Apply ksp plugin
	ksp("org.babyfish.jimmer:jimmer-ksp:0.1.29")

    ...ommit other dependency...
}

// Step4: Add generated sources into compile path.
// Without this configuration, gradle command can still run.
// However, Intellij cannot find the generated source.
kotlin {
    sourceSets.main {
        kotlin.srcDir("build/generated/ksp/main/kotlin")
    }
}
```

</TabItem>
</Tabs>

## 定义实体

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookStore.java"
package org.babyfish.jimmer.sql.example.model;

import javax.validation.constraints.Null;
import java.util.List;

import org.babyfish.jimmer.sql.Entity;
import org.babyfish.jimmer.sql.Id;
import org.babyfish.jimmer.sql.OneToMany;
import org.babyfish.jimmer.sql.Key;

@Entity
public interface BookStore {

    @Id
    long id();

    @Key
    String name();

    @Null
    String website();

    @OneToMany(mappedBy = "store")
    List<Book> books();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookStore.kt"
package org.babyfish.jimmer.sql.example.model

import org.babyfish.jimmer.sql.Entity
import org.babyfish.jimmer.sql.Id
import org.babyfish.jimmer.sql.OneToMany
import org.babyfish.jimmer.sql.Key

@Entity
public interface BookStore {

    @Id
    val id: Long

    @Key
    val name: String

    val website: String?

    @OneToMany(mappedBy = "store")
    val books: List<Book>
}
```

</TabItem>
</Tabs>

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
package org.babyfish.jimmer.sql.example.model;

import javax.validation.constraints.Null;
import java.math.BigDecimal;
import java.util.List;

import org.babyfish.jimmer.sql.Entity;
import org.babyfish.jimmer.sql.JoinColumn;
import org.babyfish.jimmer.sql.Key;
import org.babyfish.jimmer.sql.ManyToOne;
import org.babyfish.jimmer.sql.ManyToMany;

@Entity
public interface Book {

    @Id
    long id();

    @Key
    String name();

    @Key
    int edition();

    BigDecimal price();

    @Null
    @ManyToOne(optional = true)
    BookStore store();

    @ManyToMany
    @JoinTable(
            name = "BOOK_AUTHOR_MAPPING",
            joinColumnName = "BOOK_ID",
            inverseJoinColumnName = "AUTHOR_ID"
    )
    List<Author> authors();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"
package org.babyfish.jimmer.sql.example.model

import java.math.BigDecimal
import java.util.UUID

import org.babyfish.jimmer.sql.Entity
import org.babyfish.jimmer.sql.JoinColumn
import org.babyfish.jimmer.sql.Key
import org.babyfish.jimmer.sql.ManyToOne
import org.babyfish.jimmer.sql.ManyToMany

@Entity
public interface Book {

    @Id
    val id: Long

    @Key
    val name: String

    @Key
    val edition: Int

    val price: BigDecimal

    @ManyToOne(optional = true)
    val store: BookStore?

    @ManyToMany
    @JoinTable(
            name = "BOOK_AUTHOR_MAPPING",
            joinColumns = @JoinColumn(name = "BOOK_ID"),
            inverseJoinColumns = @JoinColumn(name = "AUTHOR_ID")
    )
    val authors: List<Author>
}
```

</TabItem>
</Tabs>

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Author.java"
package org.babyfish.jimmer.sql.example.model;

import java.util.List;
import org.babyfish.jimmer.sql.Entity;
import org.babyfish.jimmer.sql.Key;
import org.babyfish.jimmer.sql.ManyToMany;

@Entity
public interface Author {

    @Id
    long id();

    @Key
    String firstName();

    @Key
    String lastName();

    Gender gender();

    @ManyToMany(mappedBy = "authors")
    List<Book> books();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java title="Author.kt"
package org.babyfish.jimmer.sql.example.model

import org.babyfish.jimmer.sql.Entity
import org.babyfish.jimmer.sql.Key
import org.babyfish.jimmer.sql.ManyToMany

@Entity
public interface Author {

    @Id
    val id: Long

    @Key
    val firstName: String

    @Key
    val lastName: String

    val gender: Gender

    @ManyToMany(mappedBy = "authors")
    val books: List<Book>
}
```

</TabItem>
</Tabs>

Author类中使用了一个Gender类型，这是一个枚举类型，其定义如下

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Gender.java"
package org.babyfish.jimmer.sql.example.model;

public enum Gender {
    MALE,
    FEMALE
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```java title="Gender.kt"
package org.babyfish.jimmer.sql.example.model

enum class Gender {
    MALE,
    FEMALE
}
```

</TabItem>
</Tabs>

## 创建SqlClient

JSqlClient/KSqlClient是jimmer-sql所有Api的入口，因此，需要先创建SqlClient。

:::tip

Java API和Kotlin API的入口不同

- Java API的入口是`org.babyfish.jimmer.sql.JSqlClient`
- Kotlin API的入口是`org.babyfish.jimmer.sql.kt.KSqlClient`
:::

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
package org.babyfish.jimmer.sql.example;

import org.babyfish.jimmer.sql.JSqlClient;
import org.babyfish.jimmer.sql.example.model.Gender;
import org.babyfish.jimmer.sql.runtime.ConnectionManager;
import org.babyfish.jimmer.sql.runtime.ScalarProvider;

import org.babyfish.jimmer.sql.example.model.Gender;
import javax.sql.DataSource;

DataSource dataSource = ...;

JSqlClient sqlClient = JSqlClient
    .newBuilder()
    .setConnectionManager(
        ConnectionManager.simpleConnectionManager(dataSource)
    )
    .addScalarProvider(
            ScalarProvider.enumProviderByString(Gender.class, it -> {
                it.map(Gender.MALE, "M");
                it.map(Gender.FEMALE, "F");
            })
    )
    .build();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
import org.babyfish.jimmer.example.kt.sql.model.Gender
import org.babyfish.jimmer.sql.kt.newKSqlClient
import org.babyfish.jimmer.sql.runtime.ScalarProvider
import javax.sql.DataSource

val sqlClient = newKSqlClient {
    setConnectionManager {
        dataSource.connection.use {
            proceed(it)
        }
        addScalarProvider(
            ScalarProvider.enumProviderByString(Gender::class.java) {
                it.map(Gender.MALE, "M")
                it.map(Gender.FEMALE, "F")
            }
        )
    }
}
```

</TabItem>
</Tabs>

:::note
这个例子，仅仅让jimmer-sql能根据连接池自动创建连接。

关于和Spring事务机制配合的话题，其参见[SqlClient](./sql-client)
:::

## 查询

### 简单查询

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = sqlClient
    .createQuery(BookTable.class, (q, book) -> {
        return q
            .where(book.name().like("Java"))
            .select(book);
    })
    .execute();
books.forEach(System.out::println);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kt
val books = sqlClient
    .createQuery(Book::class) {
        where(table.name like "Kotlin")
        select(table)
    }
    .execute()
books.forEach(::println)
```

</TabItem>
</Tabs>

最终生成的SQL如下

```sql
select 
    tb_1_.ID, 
    tb_1_.NAME, 
    tb_1_.EDITION, 
    tb_1_.PRICE, 
    tb_1_.STORE_ID 
from BOOK as tb_1_ 
where tb_1_.NAME like ?
```

### 使用表连接

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = sqlClient
    .createQuery(BookTable.class, (q, book) -> {
        return q
            .where(
                book
                // highlight-next-line
                .store()
                .name()
                .eq("MANNING")
            )
            .select(book);
    })
    .execute();
books.forEach(System.out::println);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kt
val books = sqlClient
    .createQuery(Book::class) {
        where(
            table
                // highlight-next-line
                .store
                .name eq "MANNING"
        )
        select(table)
    }
    .execute()
books.forEach(::println)
```

</TabItem>
</Tabs>

最终生成的SQL如下

```sql
select 
    tb_1_.ID, 
    tb_1_.NAME, 
    tb_1_.EDITION, 
    tb_1_.PRICE, 
    tb_1_.STORE_ID 
from BOOK as tb_1_
/* highlight-next-line */
inner join BOOK_STORE as tb_2_ on tb_1_.STORE_ID = tb_2_.ID 
where tb_2_.NAME = ?
```

### 使用子查询

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = sqlClient
    .createQuery(BookTable.class, (q, book) -> {
        return q
            .where(
                book.id().in(
                    //highlight-next-line
                    q.createSubQuery(
                        AuthorTableEx.class, (sq, author) -> {
                            return sq
                                .where(author.firstName().like("Alex"))
                                .select(author.books().id());
                        }
                    )
                )
            )
            .select(book);
    }).execute();
books.forEach(System.out::println);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kt
val books = sqlClient
    .createQuery(Book::class) {
        where(
            // highlight-next-line
            table.id valueIn subQuery(Author::class) {
                where(table.firstName eq "Alex")
                select(table.books.id)
            }
        )
        select(table)
    }
    .execute()
books.forEach(::println)
```

</TabItem>
</Tabs>

最终生成的SQL如下

```sql
select 
    tb_1_.ID, 
    tb_1_.NAME, 
    tb_1_.EDITION, 
    tb_1_.PRICE, 
    tb_1_.STORE_ID 
from BOOK as tb_1_ 
where tb_1_.ID in (
    /* highlight-next-line */
    select tb_3_.BOOK_ID 
    from AUTHOR as tb_2_ 
    inner join BOOK_AUTHOR_MAPPING as tb_3_ 
    on tb_2_.ID = tb_3_.AUTHOR_ID 
    where tb_2_.FIRST_NAME like ?
)
```

### 分组查询

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
// Column1: BookStore id
// Column2: Average book price of each BookStore
List<Tuple2<Long, BigDecimal>> tuples = sqlClient
    .createQuery(BookTable.class, (q, book) -> {
        return q
            // highlight-next-line
            .groupBy(book.store().id())
            .select(
                book.store().id(),
                // highlight-next-line
                book.price().avg()
            );
    }).execute();
tuples.forEach(System.out::println);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val tuples = sqlClient
    .createQuery(Book::class) {
        // highlight-next-line
        groupBy(table.store.id)
        select(
            table.store.id,
            // highlight-next-line
            avg(table.price)
        )
    }
    .execute()
tuples.forEach(::println)
```

</TabItem>
</Tabs>

最终生成的SQL如下

```sql
select 
    tb_1_.STORE_ID, 
    /* highlight-next-line */
    avg(tb_1_.PRICE) 
from BOOK as tb_1_ 
/* highlight-next-line */
group by tb_1_.STORE_ID
```

### 分页查询

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
ConfigurableTypedRootQuery<BookTable, Book> bookQuery =
    sqlClient.createQuery(BookTable.class, (q, book) -> {
        return q
            .where(book.store().name().eq("O'REILLY"))
            .orderBy(book.name())
            .select(book);
    });

TypedRootQuery<Long> countQuery = bookQuery
    // highlight-next-line
    .reselect((oldQuery, book) ->
        oldQuery.select(book.count())
    )
    .withoutSortingAndPaging();

int rowCount = countQuery.execute().get(0).intValue();
System.out.println("Total row count: " + rowCount);

List<Book> rows = bookQuery
    // highlight-next-line
    .limit(rowCount / 3, rowCount / 3)
    .execute();
System.out.println("Top 2 rows: " + top2Rows);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val bookQuery = sqlClient
    .createQuery(Book::class) {
        where(table.store.name eq "O'REILLY")
        orderBy(table.name)
        select(table)
    }

val countQuery = bookQuery
    // highlight-next-line
    .reselect {
        select(count(table))
    }
    .withoutSortingAndPaging()

val rowCount = countQuery.execute()[0].toInt()
println("Total row count: $rowCount")

val books = bookQuery
    .limit(limit = rowCount / 3, offset = rowCount / 3)
    .execute()
books.forEach(::println)
```

</TabItem>
</Tabs>

最终生成会生成两条SQL

1.
    ```sql
    /* highlight-next-line */
    select count(tb_1_.ID) 
    from BOOK as tb_1_ 
    inner join BOOK_STORE as tb_2_ on tb_1_.STORE_ID = tb_2_.ID 
    where tb_2_.NAME = ?
    ```

2.
    ```sql
    select 
        tb_1_.ID, 
        tb_1_.NAME, 
        tb_1_.EDITION, 
        tb_1_.PRICE, 
        tb_1_.STORE_ID 
    from BOOK as tb_1_ 
    inner join BOOK_STORE as tb_2_ on tb_1_.STORE_ID = tb_2_.ID 
    where tb_2_.NAME = ? 
    order by tb_1_.NAME asc 
    /* highlight-next-line */
    limit ?
    ```

### 混合Native SQL

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
// Column 1: Book object
// Column 2: Global price rank
// Column 3: Local price rank in its BookStore
List<Tuple3<Book, Integer, Integer>> tuples = sqlClient
    .createQuery(BookTable.class, (q, book) -> {
        return q.select(
            book,
            // highlight-next-line
            Expression.numeric().sql(
                Integer.class,
                "rank() over(order by %e desc)",
                it -> it.expression(book.price())
            ),
            // highlight-next-line
            Expression.numeric().sql(
                Integer.class,
                "rank() over(partition by %e order by %e desc)",
                it -> it
                        .expression(book.store().id())
                        .expression(book.price())
            )
        );
    }).execute();
tuples.forEach(System.out::println);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kt
// Column 1: Book object
// Column 2: Global price rank
// Column 3: Local price rank in its BookStore
val tuples = sqlClient
    .createQuery(Book::class) {
        select(
            table,
            // highlight-next-line
            sql(
                Int::class,
                "rank() over(order by %e desc)"
            ) {
                expression(table.price)
            },
            // highlight-next-line
            sql(
                Int::class,
                "rank() over(partition by %e order by %e desc)"
            ) {
                expression(table.store.id)
                expression(table.price)
            }
        )
    }
    .execute()
tuples.forEach(::println)
```

</TabItem>
</Tabs>

最终生成的SQL如下

```sql
select 
    
    tb_1_.ID, 
    tb_1_.NAME, 
    tb_1_.EDITION, 
    tb_1_.PRICE, 
    tb_1_.STORE_ID, 
    
    /* highlight-next-line */
    rank() over(order by tb_1_.PRICE desc), 

    /* highlight-next-line */
    rank() over(partition by tb_1_.STORE_ID order by tb_1_.PRICE desc) 
from BOOK as tb_1_
```

### 使用对象抓取器

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = sqlClient
    .createQuery(BookTable.class, (q, book) -> {
        return q
            .orderBy(book.name())
            .select(
                // highlight-next-line
                book.fetch(
                    BookFetcher.$
                        .allScalarFields()
                        // highlight-next-line
                        .store(
                            BookStoreFetcher.$
                                .allScalarFields()
                        )
                        // highlight-next-line
                        .authors(
                            AuthorFetcher.$
                                .allScalarFields()
                        )
                )
            );
    })
    .execute();
books.forEach(System.out::println);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient
    .createQuery(Book::class) {
        select(
            // highlight-next-line
            table.fetchBy { 
                allScalarFields()
                // highlight-next-line
                store { 
                    allScalarFields()
                }
                // highlight-next-line
                authors { 
                    allScalarFields()
                }
            }
        )
    }
    .execute()
books.forEach(::println)
```

</TabItem>
</Tabs>

最终生成的三条SQL

1.
    ```sql
    select 
        tb_1_.ID, 
        tb_1_.NAME, 
        tb_1_.EDITION, 
        tb_1_.PRICE, 
        tb_1_.STORE_ID 
    from BOOK as tb_1_ 
    order by tb_1_.NAME asc
    ```

2.
    ```sql
    select 
        tb_1_.ID, 
        tb_1_.NAME, 
        tb_1_.WEBSITE 
    from BOOK_STORE as tb_1_ 
    where tb_1_.ID in (?, ?)
    ```
3.    
    ```sql
    select 
        tb_1_.BOOK_ID, 
        tb_1_.AUTHOR_ID, 
        tb_3_.FIRST_NAME, 
        tb_3_.LAST_NAME, 
        tb_3_.GENDER 
    from BOOK_AUTHOR_MAPPING as tb_1_ 
    inner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID 
    where tb_1_.BOOK_ID in (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ```

这里，第一条SQL用于查询Book实体本身；后续两条额外的SQL负责查询`Book`的关联对象，它们在主查询之后执行。

## 修改

jimmer-sql提供两种方式修改数据库，语句和指令

- 语句：可以执行update和delete，适用于逻辑简单但需要批量操作的场合。
- 指令：可以执行insert、update和delete，适用于逻辑复杂的场合。

### 使用修改语句

#### update语句

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
int affectedRowCount = sqlClient
    .createUpdate(BookTable.class, (u, book) -> {
        u.set(
            book.price(), 
            book.price().plus(new BigDecimal(10))
        );
        u.where(book.name().like("Java"));
    })
    .execute();
System.out.println("Affected row count: " + affectedRowCount);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val affectedRowCount = sqlClient
    .createUpdate(Book::class) {
        set(table.price, table.price + BigDecimal(20))
        where(table.name like "Kotlin")
    }
    .execute()
println("Affected row count: $affectedRowCount")
```

</TabItem>
</Tabs>

最终生成如下SQL

```sql
update BOOK tb_1_ 
set PRICE = tb_1_.PRICE + ? 
where tb_1_.NAME like ?
```

#### delete语句

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
int affectedRowCount = sqlClient
    .createDelete(BookTable.class, (d, book) -> {
        d.where(book.name().like("Java"));
    })
    .execute();
System.out.println("Affected row count: " + affectedRowCount);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val affectedRowCount = sqlClient
    .createDelete(Book::class) {
        where(table.name like "Kotlin")
    }
    .execute()
println("Affected row count: $affectedRowCount")
```

</TabItem>
</Tabs>

最终生成如下SQL

```sql
delete from BOOK as tb_1_ where tb_1_.NAME like ?
```

### 使用修改指令

#### Save指令

由于jimmer-core提供的不可变实体对象具备动态性，所以实体对象可以表述各种各样的信息，比如：

- 残缺的对象
- 完整的对象
- 较浅的对象树
- 较深的对象树

无论是何种情况，都可以使用Save指令，靠一句代码对其进行插入、更新、或保存（所谓保存，即插入或更新）。

为了给予一个感性认知和初步了解，本文示范两个例子，保存单个对象，保存对象树。

##### 1. 保存单个对象

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
SimpleSaveResult<Book> result = sqlClient
    .getEntities()
    .save(
        BookDraft.$.produce(book ->
            book.setName("BookName")
                .setEdition(1)
                .setPrice(new BigDecimal(50))
        )
    );
System.out.println(
    "Affected row count: " + 
    result.getTotalAffectedRowCount()
);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val result = sqlClient
    .entities
    .save(
        new(Book::class).by { 
            name = "BookName"
            edition = 1
            price = BigDecimal(50)
        }
    )
println("Affected row count: ${result.totalAffectedRowCount}")
```

</TabItem>
</Tabs>

这条指令的实际执行逻辑依赖于数据库中现有数据，假设数据中不存在`name`为"BookName"且`edition`为1的书籍，则生成如下这些SQL

1.
    ```sql
    select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION 
    from BOOK as tb_1_ 
    where tb_1_.NAME = ? and tb_1_.EDITION = ?
    ```

2.
    ```sql
    insert into BOOK(ID, NAME, EDITION, PRICE) values(?, ?, ?, ?)
    ```

##### 2. 保存对象树

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
SimpleSaveResult<Book> result = sqlClient
    .getEntities()
    .saveCommand(
        BookDraft.$.produce(book -> {
            book.setName("BookName")
                .setEdition(1)
                .setPrice(new BigDecimal(50))
                .setStore(store -> 
                    store.setName("StoreName")
                )
                .addIntoAuthors(author -> {
                    author
                            .setFirstName("AuthorFirstName-1")
                            .setLastName("AuthorLastName-1")
                            .setGender(Gender.MALE);
                })
                .addIntoAuthors(author -> {
                    author
                            .setFirstName("AuthorFirstName-2")
                            .setLastName("AuthorLastName-2")
                            .setGender(Gender.FEMALE);
                });
        })
    )
    .configure(
            AbstractSaveCommand.Cfg::setAutoAttachingAll
    )
    .execute();

System.out.println(

    "Affected row count: " +
    result.getTotalAffectedRowCount() +

    "\nAffected row count of table 'BOOK': " +
    result.getAffectedRowCount(AffectedTable.of(Book.class)) +

    "\nAffected row count of table 'BOOK_STORE': " +
    result.getAffectedRowCount(AffectedTable.of(BookStore.class)) +

    "\nAffected row count of table 'AUTHOR': " +
    result.getAffectedRowCount(AffectedTable.of(Author.class)) +

    "\nAffected row count of middle table 'BOOK_AUTHOR_MAPPING': " +
    result.getAffectedRowCount(
        AffectedTable.of(BookTableEx.class, BookTableEx::authors)
    )
);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val result = sqlClient
    .entities
    .save(
        new(Book::class).by { 
            name = "BookName"
            edition = 1
            price = BigDecimal(50)
            store().apply { 
                name = "StoreName"
            }
            authors().addBy { 
                firstName = "AuthorFirstName-1"
                lastName = "AuthorFirstName-1"
                gender = Gender.MALE
            }
            authors().addBy {
                firstName = "AuthorFirstName-2"
                lastName = "AuthorFirstName-2"
                gender = Gender.FEMALE
            }
        }
    ) {
        setAutoAttachingAll()
    }
println(
    """Affected row count: ${result.totalAffectedRowCount}
        |Affected row count of table 'BOOK': ${
            result.affectedRowCount(Book::class)
        }
        |Affected row count of table 'BOOK_STORE': ${
            result.affectedRowCount(BookStore::class)
        }
        |Affected row count of table 'AUTHOR': ${
            result.affectedRowCount(Author::class)
        }Affected row count of middle table 'BOOK_AUTHOR_MAPPING': ${
            result.affectedRowCount(Book::authors)
        }
    """.trimMargin()
)
```

</TabItem>
</Tabs>

这条指令的实际执行逻辑依赖于数据库中现有数据，假设对象树中所有对象在数据库中都不存在，则生成如下这些SQL

1. 
    ```sql
    select tb_1_.ID, tb_1_.NAME 
    from BOOK_STORE as tb_1_ 
    where tb_1_.NAME = ?
    ```
2.
    ```sql
    insert into BOOK_STORE(ID, NAME) values(?, ?)
    ```

3.
    ```sql
    select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION 
    from BOOK as tb_1_ 
    where tb_1_.NAME = ? and tb_1_.EDITION = ?
    ```
4.
    ```sql
    insert into BOOK(ID, NAME, EDITION, PRICE, STORE_ID) 
    values(?, ?, ?, ?, ?)
    ```

5.

    ```sql
    select tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME 
    from AUTHOR as tb_1_ 
    where tb_1_.FIRST_NAME = ? and tb_1_.LAST_NAME = ?
    ```
6.

    ```sql
    insert into AUTHOR(ID, FIRST_NAME, LAST_NAME, GENDER) 
    values(?, ?, ?, ?)
    ```

7.

    ```sql
    select tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME 
    from AUTHOR as tb_1_ 
    where tb_1_.FIRST_NAME = ? and tb_1_.LAST_NAME = ?
    ```
8.

    ```sql
    insert into AUTHOR(ID, FIRST_NAME, LAST_NAME, GENDER) 
    values(?, ?, ?, ?)
    ```

9.
    ```sql
    insert into BOOK_AUTHOR_MAPPING(BOOK_ID, AUTHOR_ID) 
    values 
        (?, ?), 
        (?, ?)
    ```

#### Delete指令

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
Collection<Long> ids = ...

DeleteResult result = sqlClient
    .getEntities()
    .batchDelete(Book.class, ids);

System.out.println(
    
    "Affected row count: " + 
    result.getTotalAffectedRowCount() +

    "\nAffected row count of table 'BOOK': " +
    result.getAffectedRowCount(AffectedTable.of(Book.class)) +
    
    "\nAffected row count of middle table 'BOOK_AUTHOR_MAPPING': " +
    result.getAffectedRowCount(
        AffectedTable.of(BookTableEx.class, BookTableEx::authors)
    )
);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val ids: Collection<Long> = ...
val result = sqlClient
    .entities
    .batchDelete(Book::class, ids)
println(
    """Affected row count: ${result.totalAffectedRowCount}
        |Affected row count of table 'BOOK': ${
            result.affectedRowCount(Book::class)
        }Affected row count of middle table 'BOOK_AUTHOR_MAPPING': ${
            result.affectedRowCount(Book::authors)
        }
    """.trimMargin()
)
```

</TabItem>
</Tabs>

最终生成的SQL如下

1. 
    ```sql
    delete from BOOK_AUTHOR_MAPPING 
    where BOOK_ID in(?, ?, ?, ?)
    ```

2. 
    ```sql
    delete from BOOK 
    where ID in(?, ?, ?, ?)
    ```

打印结果如下

```
Affected row count: 9
Affected row count of table 'BOOK': 4
Affected row count of middle table 'BOOK_AUTHOR_MAPPING': 5
```
